{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/ImprovedNoise.js","webpack:///./src/vertex-color+noise-vert.glsl","webpack:///./src/vertex-color+noise-frag.glsl","webpack:///./src/geometry-atoll-terrain.js","webpack:///./src/vertex-color+noise.js","webpack:///./src/index.js"],"names":["enumerable","get","getter","value","key","bind","module","Object","prototype","hasOwnProperty","call","object","property","exports","p","i","fade","t","lerp","a","b","grad","hash","x","y","z","h","u","v","noise","floorX","floorY","floorZ","X","Y","Z","xMinus1","yMinus1","zMinus1","w","A","AA","AB","B","BA","BB","AFRAME","registerGeometry","schema","buffer","type","default","meanElevation","plateauRadius","min","plateauElevationMin","plateauYinColor","undefined","plateauYangColor","middleRadius","unitSize","max","far","landYinColor","landYangColor","seaYinColor","seaYangColor","log","init","data","perlin","SEED","Math","random","SQRT3HALF","sqrt","SIZE","round","UNIT_SIZE","PLATEAU_RADIUS","PLATEAU_EDGE","INNER_RADIUS","OUTER_RADIUS","FAR","MASK_EDGE","SCAN_SIZE","ceil","LAND_YIN_COLOR","THREE","Color","LAND_YANG_COLOR","PLATEAU_YIN_COLOR","PLATEAU_YANG_COLOR","SEA_YIN_COLOR","SEA_YANG_COLOR","seaAverageColor","clone","BEACH_COLOR","ROCK_COLOR","plateauElevation","quality","console","vertices","positions","vertexLookup","vertexInd","j","r","push","Vector3","pitColor","SCALE5","SCALE25","SCALE3","SCALE12","colors","vertexBehavior","Array","length","faceIndices","vertexAInd","vertexA","vertexBInd","vertexCInd","vertexDInd","mix","color","g","neighbors","nearby","convolution","land","sea","n","bufferGeometry","BufferGeometry","setIndex","addAttribute","Float32BufferAttribute","computeVertexNormals","this","geometry","getElevation","nearVertices","index","floor","elevSum","scoreSum","forEach","vert","score","pow","registerShader","sunPosition","timeMsec","is","sunPos","material","ShaderMaterial","uniforms","sunNormal","normalize","wavesOffset","vertexShader","fragmentShader","update","time","sin","cos","registerPrimitive","defaultComponents","primitive","shader","vertexColors","mappings"],"mappings":"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","file":"aframe-atoll-terrain.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","// http://mrl.nyu.edu/~perlin/noise/\n\nvar ImprovedNoise = function () {\n\n\tvar p = [ 151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,\n\t\t 23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,\n\t\t 174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,\n\t\t 133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,\n\t\t 89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,\n\t\t 202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,\n\t\t 248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,\n\t\t 178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,\n\t\t 14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,\n\t\t 93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180 ];\n\n\tfor (var i = 0; i < 256 ; i ++) {\n\n\t\tp[256 + i] = p[i];\n\n\t}\n\n\tfunction fade(t) {\n\n\t\treturn t * t * t * (t * (t * 6 - 15) + 10);\n\n\t}\n\n\tfunction lerp(t, a, b) {\n\n\t\treturn a + t * (b - a);\n\n\t}\n\n\tfunction grad(hash, x, y, z) {\n\n\t\tvar h = hash & 15;\n\t\tvar u = h < 8 ? x : y, v = h < 4 ? y : h == 12 || h == 14 ? x : z;\n\t\treturn ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);\n\n\t}\n\n\treturn {\n\n\t\tnoise: function (x, y, z) {\n\n\t\t\tvar floorX = ~~x, floorY = ~~y, floorZ = ~~z;\n\n\t\t\tvar X = floorX & 255, Y = floorY & 255, Z = floorZ & 255;\n\n\t\t\tx -= floorX;\n\t\t\ty -= floorY;\n\t\t\tz -= floorZ;\n\n\t\t\tvar xMinus1 = x - 1, yMinus1 = y - 1, zMinus1 = z - 1;\n\n\t\t\tvar u = fade(x), v = fade(y), w = fade(z);\n\n\t\t\tvar A = p[X] + Y, AA = p[A] + Z, AB = p[A + 1] + Z, B = p[X + 1] + Y, BA = p[B] + Z, BB = p[B + 1] + Z;\n\n\t\t\treturn lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z),\n\t\t\t\t\t\t\tgrad(p[BA], xMinus1, y, z)),\n\t\t\t\t\t\tlerp(u, grad(p[AB], x, yMinus1, z),\n\t\t\t\t\t\t\tgrad(p[BB], xMinus1, yMinus1, z))),\n\t\t\t\t\tlerp(v, lerp(u, grad(p[AA + 1], x, y, zMinus1),\n\t\t\t\t\t\t\tgrad(p[BA + 1], xMinus1, y, z - 1)),\n\t\t\t\t\t\tlerp(u, grad(p[AB + 1], x, yMinus1, zMinus1),\n\t\t\t\t\t\t\tgrad(p[BB + 1], xMinus1, yMinus1, zMinus1))));\n\n\t\t}\n\t}\n};\n\nmodule.exports = ImprovedNoise;\n","module.exports = \"// vertex-color+noise-vert.glsl - vertex shader\\n// Copyright © 2019 P. Douglas Reeder under the MIT License\\n\\nuniform vec3 sunNormal;\\nuniform vec3 wavesOffset;\\n\\nattribute float behavior;\\n\\nvarying vec3 interpColor;\\nvarying vec3 noisePosition;\\nvarying float sunFactor;\\n\\nvoid main() {\\n    interpColor = color;\\n\\n    const vec3 zero = vec3(0.0, 0.0, 0.0);\\n    noisePosition = position + ((behavior > 0.0) ? wavesOffset : zero);\\n\\n    sunFactor = 0.5 + max(dot(normal, sunNormal), 0.0);\\n\\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\\n\"","module.exports = \"// vertex-color+noise-frag.glsl - fragment shader\\n// Copyright © 2019 P. Douglas Reeder under the MIT License, except as noted\\n\\nvarying vec3 interpColor;\\nvarying vec3 noisePosition;\\nvarying float sunFactor;\\n\\n\\n//\\n// Description : Array and textureless GLSL 2D simplex noise function.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : stegu\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//               https://github.com/stegu/webgl-noise\\n//\\n\\nvec3 mod289(vec3 x) {\\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec2 mod289(vec2 x) {\\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec3 permute(vec3 x) {\\n    return mod289(((x*34.0)+1.0)*x);\\n}\\n\\nfloat snoise(vec2 v)\\n{\\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\\n    0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\\n    -0.577350269189626,  // -1.0 + 2.0 * C.x\\n    0.024390243902439); // 1.0 / 41.0\\n    // First corner\\n    vec2 i  = floor(v + dot(v, C.yy) );\\n    vec2 x0 = v -   i + dot(i, C.xx);\\n\\n    // Other corners\\n    vec2 i1;\\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\\n    //i1.y = 1.0 - i1.x;\\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\\n    // x1 = x0 - i1 + 1.0 * C.xx ;\\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\\n    vec4 x12 = x0.xyxy + C.xxzz;\\n    x12.xy -= i1;\\n\\n    // Permutations\\n    i = mod289(i); // Avoid truncation effects in permutation\\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\\n    + i.x + vec3(0.0, i1.x, 1.0 ));\\n\\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\\n    m = m*m ;\\n    m = m*m ;\\n\\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\\n\\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\\n    vec3 h = abs(x) - 0.5;\\n    vec3 ox = floor(x + 0.5);\\n    vec3 a0 = x - ox;\\n\\n    // Normalise gradients implicitly by scaling m\\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\\n\\n    // Compute final noise value at P\\n    vec3 g;\\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\\n    return 130.0 * dot(m, g);\\n}\\n// end Ashima Arts copyright\\n\\n\\n// by \\\"sam\\\" of \\\"lolengine\\\", apparently Public Domain\\nvec3 hsv2rgb(vec3 c)\\n{\\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n}\\n// end \\\"sam\\\" of \\\"lolengine\\\"\\n\\n\\nvoid main() {\\n    float noise = snoise(noisePosition.xz) /* + snoise(noisePosition.xz*10.0) */;\\n\\n    const vec3 factor = vec3(1.0/65.0, 1.0/19.0, 1.0/6.55e4);\\n    const vec3 offsetHSV = vec3(0.5, 0.5, 0.5);\\n    vec3 noiseHSV = noise * factor + offsetHSV;\\n\\n    const vec3 offsetRGB = vec3(0.25, 0.5, 0.5);\\n    vec3 inherentColor = interpColor + hsv2rgb(noiseHSV) - offsetRGB;\\n\\n    gl_FragColor = vec4(inherentColor * sunFactor, 1.0);\\n}\\n\"","// geometry-atoll-terrain.js - geometry for aframe-atoll-terrain component\n// Copyright © 2019-2020 P. Douglas Reeder under the MIT License\n\nimport ImprovedNoise from './ImprovedNoise';\n\nAFRAME.registerGeometry('atoll-terrain', {\n    schema: {\n        buffer: {type: 'boolean', default: false},\n        meanElevation: {type: 'number', default: 10},\n        plateauRadius: {type: 'number', default: 10, min: 0},\n        plateauElevationMin: {type: 'number', default: 1, min: 0},\n        plateauYinColor: {type: 'color', default: undefined},\n        plateauYangColor: {type: 'color', default: undefined},\n        middleRadius: {type: 'number', default: 100, min: 10},\n        unitSize: {type: 'number', default: 1, min: 0.1, max: 1000},\n        far: {type: 'number', default: 4000},\n        landYinColor: {type: 'color', default: '#528d04'},\n        landYangColor: {type: 'color', default: '#278d53'},\n        seaYinColor: {type: 'color', default: '#096297'},\n        seaYangColor: {type: 'color', default: '#1b6cbc'},\n        log: {type: 'boolean', default: false}\n    },\n    init: function (data) {\n        const perlin = new ImprovedNoise();\n        const SEED = Math.random() * 100;\n        const SQRT3HALF = Math.sqrt(3) / 2;\n\n        const SIZE = Math.round(data.middleRadius / data.unitSize);\n        const UNIT_SIZE = data.middleRadius / SIZE;\n\n        const PLATEAU_RADIUS = data.plateauRadius < data.middleRadius-2*UNIT_SIZE ? data.plateauRadius : data.middleRadius-2*UNIT_SIZE;\n        const PLATEAU_EDGE = PLATEAU_RADIUS + UNIT_SIZE;\n\n        const INNER_RADIUS = (SIZE-1) * UNIT_SIZE + 0.0001;\n        const OUTER_RADIUS = (SIZE+1) * UNIT_SIZE + 0.0001;\n        const FAR = data.far > OUTER_RADIUS ? data.far : OUTER_RADIUS;\n        const MASK_EDGE = INNER_RADIUS / 4;\n        const SCAN_SIZE = Math.ceil(SIZE * 1.16);   // empirically determined\n\n        const LAND_YIN_COLOR = new THREE.Color(data.landYinColor);\n        const LAND_YANG_COLOR = new THREE.Color(data.landYangColor);\n        const PLATEAU_YIN_COLOR = new THREE.Color(data.plateauYinColor ? data.plateauYinColor : data.landYinColor);\n        const PLATEAU_YANG_COLOR = new THREE.Color(data.plateauYangColor ? data.plateauYangColor : data.landYangColor);\n        const SEA_YIN_COLOR = new THREE.Color(data.seaYinColor);\n        const SEA_YANG_COLOR = new THREE.Color(data.seaYangColor);\n        let seaAverageColor = SEA_YIN_COLOR.clone();\n        seaAverageColor.lerp(SEA_YANG_COLOR, 0.5);\n        const BEACH_COLOR = new THREE.Color(0x71615b);   // brownish-gray beach\n        const ROCK_COLOR = new THREE.Color(0x837E7C);   // granite\n\n        let plateauElevation = data.meanElevation;\n        // plateau has elevation of center\n        for (let quality = 25; quality <= 1500; quality *= 5) {\n            // The largest scale (625) is constrained to avoid all mountain or all sea.\n            plateauElevation += perlin.noise((0+data.middleRadius) / quality, (0+data.middleRadius) / quality, SEED) * Math.min(quality / 2, 62.5);\n        }\n        plateauElevation = Math.max(plateauElevation, data.plateauElevationMin);\n\n        if (data.log) {\n            console.log(\"atoll-terrain\", \"PLATEAU_EDGE=\"+PLATEAU_EDGE, \"plateauElevation=\"+plateauElevation,\n                \"SIZE=\"+SIZE, \"SCAN_SIZE=\"+SCAN_SIZE, \"UNIT_SIZE=\"+UNIT_SIZE,\n                \"middleRadius=\"+data.middleRadius, \"FAR=\"+FAR);\n        }\n\n        let vertices = [];    // one element (THREE.Vector3) per vertex; temporary storage during generation\n        let positions = [];   // three elements (x,y,z) per vertex\n\n        // vertex locations\n        let vertexLookup = {};\n        vertexLookup[-SCAN_SIZE-1] = {};\n        let vertexInd = 0;\n        for (let i= -SCAN_SIZE; i<=SCAN_SIZE; ++i) {\n            vertexLookup[i] = {};\n            for (let j= -SCAN_SIZE; j<=SCAN_SIZE; ++j) {\n                let x = i * SQRT3HALF * UNIT_SIZE;\n                let z = (j - i/2) * UNIT_SIZE;\n                let r = Math.sqrt(x*x + z*z);\n                if (r <= OUTER_RADIUS) {\n                    let y;\n                    if (data.plateauRadius > 0 && r <= PLATEAU_EDGE) {\n                        y = plateauElevation;\n                    } else if (r <= INNER_RADIUS) {\n                        y = data.meanElevation;\n                        // generates smooth noisy terrain\n                        for (let quality = 25; quality <= 1500; quality *= 5) {\n                            // The largest scale (625) is constrained to avoid all mountain or all sea.\n                            y += perlin.noise((x+data.middleRadius) / quality, (z+data.middleRadius) / quality, SEED) * Math.min(quality / 2, 62.5);\n                        }\n\n                        if (data.plateauRadius > 0) {\n                            y = plateauElevation + (y - plateauElevation) * Math.min(r - PLATEAU_EDGE, MASK_EDGE) / MASK_EDGE;\n                        }\n                        y *= Math.min(INNER_RADIUS - r, MASK_EDGE) / MASK_EDGE;\n\n                        if (y > 0) {\n                            let quality = 5;\n                            // This has a weaker effect, to avoid covering flattish terrain with divots.\n                            y += perlin.noise((x + data.middleRadius) / quality, (z + data.middleRadius) / quality, SEED) * quality / 7;\n                        }\n\n                        // flattens the bottom, so it's continuous with the plain\n                        if (y < 0) {\n                            y = 0;\n                        }\n                    } else if (r <= data.middleRadius) {\n                        y = 0;\n                    } else {\n                        x *= FAR / r;\n                        z *= FAR / r;\n                        y = 0;\n                    }\n\n                    vertexLookup[i][j] = vertexInd++;\n                    vertices.push(new THREE.Vector3(x, y, z));\n                    positions.push(x, y, z);\n                }\n            }\n        }\n        vertexLookup[SCAN_SIZE+1] = {};\n\n        // vertex colors & behaviors, and faces\n        let pitColor = new THREE.Color(0x404040);   // dark gray\n        pitColor.lerp(LAND_YIN_COLOR, 0.75);\n        const SCALE5 = UNIT_SIZE * 5, SCALE25 = UNIT_SIZE * 25;\n        const SCALE3 = UNIT_SIZE * 3, SCALE12 = UNIT_SIZE * 12;\n\n        let colors = [];   // three elements (r,g,b) per vertex\n\n        const BEHAVIOR_STATIONARY = 0;\n        const BEHAVIOR_WAVES = 10;\n        let vertexBehavior = new Array(vertices.length);   // one element (behavior enum) per vertex\n\n        let faceIndices = [];   // three elements (vertex indexes) per face\n\n        for (let i= -SCAN_SIZE; i<=SCAN_SIZE; ++i) {\n            for (let j = -SCAN_SIZE; j <= SCAN_SIZE; ++j) {\n                let vertexAInd = vertexLookup[i][j];\n                let vertexA = vertices[vertexAInd];\n                if (vertexA) {\n                    let r = Math.sqrt(vertexA.x*vertexA.x + vertexA.z*vertexA.z);\n                    let vertexBInd = vertexLookup[i][j-1];\n                    let vertexCInd = vertexLookup[i-1][j-1];\n                    let vertexDInd = vertexLookup[i-1][j];\n                    if (data.plateauRadius > 0 && r < PLATEAU_RADIUS && (data.plateauYinColor || data.plateauYangColor)) {\n                        let mix = (1.73205 + perlin.noise((vertexA.x + data.middleRadius) / SCALE3, (vertexA.z + data.middleRadius) / SCALE3, SEED)\n                            + perlin.noise((vertexA.x + data.middleRadius) / SCALE12, (vertexA.z + data.middleRadius) / SCALE12, SEED)) / 3.4641;\n                        let color = PLATEAU_YIN_COLOR.clone();\n                        color.lerp(PLATEAU_YANG_COLOR, mix);\n                        colors.push(color.r, color.g, color.b);\n                        vertexBehavior[vertexAInd] = vertexA.y > 0 ? BEHAVIOR_STATIONARY : BEHAVIOR_WAVES;\n                    } else if (vertexA.y > 0) {   // above sea level\n                        let neighbors = new Array(6);\n                        neighbors[0] = vertices[vertexBInd];\n                        neighbors[1] = vertices[vertexCInd];\n                        neighbors[2] = vertices[vertexDInd];\n                        neighbors[3] = vertices[vertexLookup[i][j + 1]];\n                        neighbors[4] = vertices[vertexLookup[i + 1][j + 1]];\n                        neighbors[5] = vertices[vertexLookup[i + 1][j]];\n                        let nearby = new Array(12);\n                        nearby[ 0] = vertices[vertexLookup[i  ][j-2]];\n                        nearby[ 1] = vertices[vertexLookup[i-1][j-2]];\n                        nearby[ 2] = vertices[vertexLookup[i-2][j-2]];\n                        nearby[ 3] = vertices[vertexLookup[i-2][j-1]];\n                        nearby[ 4] = vertices[vertexLookup[i-2][j  ]];\n                        nearby[ 5] = vertices[vertexLookup[i-1][j+1]];\n                        nearby[ 6] = vertices[vertexLookup[i  ][j+2]];\n                        nearby[ 7] = vertices[vertexLookup[i+1][j+2]];\n                        nearby[ 8] = vertices[vertexLookup[i+2][j+2]];\n                        nearby[ 9] = vertices[vertexLookup[i+2][j+1]];\n                        nearby[10] = vertices[vertexLookup[i+2][j  ]];\n                        nearby[11] = vertices[vertexLookup[i+1][j-1]];\n                        let convolution = vertexA.y * 7;   // 1 extra to skew toward higher elevations\n                        for (let p=0; p<6; ++p) {\n                            convolution += neighbors[p].y * 3;\n                        }\n                        for (let p=0; p<12; ++p) {\n                            convolution += nearby[p].y * -2;\n                        }\n                        if (convolution > 45) {   // local peak and/or high elevation\n                            colors.push(ROCK_COLOR.r, ROCK_COLOR.g, ROCK_COLOR.b);\n                        } else {\n                            let mix = (1.73205 + perlin.noise((vertexA.x + data.middleRadius) / SCALE5, (vertexA.z + data.middleRadius) / SCALE5, SEED)\n                                + perlin.noise((vertexA.x + data.middleRadius) / SCALE25, (vertexA.z + data.middleRadius) / SCALE25, SEED)) / 3.4641;\n                            let color = LAND_YIN_COLOR.clone();\n                            color.lerp(LAND_YANG_COLOR, mix);\n                            colors.push(color.r, color.g, color.b);\n                        }\n                        vertexBehavior[vertexAInd] = BEHAVIOR_STATIONARY;\n                    } else {   // sea level\n                        if (r > INNER_RADIUS) {\n                            colors.push(seaAverageColor.r, seaAverageColor.g, seaAverageColor.b);\n                            vertexBehavior[vertexAInd] = BEHAVIOR_WAVES;\n                        } else {\n                            let neighbors = [];\n                            neighbors[0] = vertices[vertexBInd];\n                            neighbors[1] = vertices[vertexCInd];\n                            neighbors[2] = vertices[vertexDInd];\n                            neighbors[3] = vertices[vertexLookup[i][j + 1]];\n                            neighbors[4] = vertices[vertexLookup[i + 1][j + 1]];\n                            neighbors[5] = vertices[vertexLookup[i + 1][j]];\n                            let land = 0, sea = 0;\n                            for (let n = 0; n < 6; ++n) {\n                                if (neighbors[n]) {\n                                    if (neighbors[n].y > 0) {\n                                        ++land;\n                                    } else {\n                                        ++sea;\n                                    }\n                                }\n                            }\n                            if (land === 0) {   // away from shore\n                                let mix = (1.73205 + perlin.noise((vertexA.x+FAR) / SCALE3, (vertexA.z+FAR) / SCALE3, SEED)\n                                    + perlin.noise((vertexA.x+FAR) / SCALE12, (vertexA.z+FAR) / SCALE12, SEED)) / 3.4641;\n                                let color = SEA_YIN_COLOR.clone();\n                                color.lerp(SEA_YANG_COLOR, mix);\n                                colors.push(color.r, color.g, color.b);\n                                vertexBehavior[vertexAInd] = BEHAVIOR_WAVES;\n                            } else if (sea === 0) {   // pit completely surrounded by land\n                                colors.push(pitColor.r, pitColor.g, pitColor.b);\n                                vertexBehavior[vertexAInd] = BEHAVIOR_STATIONARY;\n                            } else {\n                                let color = BEACH_COLOR.clone();\n                                color.lerp(LAND_YIN_COLOR, land / (land+sea));\n                                colors.push(color.r, color.g, color.b);\n                                vertexBehavior[vertexAInd] = BEHAVIOR_STATIONARY;\n                            }\n                        }\n                    }\n                    if (typeof vertexBInd !== 'undefined' && typeof vertexCInd !== 'undefined') {\n                        faceIndices.push(vertexAInd, vertexBInd, vertexCInd);\n                    }\n                    if (typeof vertexCInd !== 'undefined' && typeof vertexDInd !== 'undefined') {\n                        faceIndices.push(vertexAInd, vertexCInd, vertexDInd);\n                    }\n                }\n            }\n        }\n\n\n        // console.log(\"positions.length=\"+positions.length,\n        //     \"colors.length=\"+colors.length, \"behavior.length=\"+behavior.length);\n\n        let bufferGeometry = new THREE.BufferGeometry();\n        bufferGeometry.setIndex(faceIndices);\n        bufferGeometry.addAttribute('position', new THREE.Float32BufferAttribute( positions, 3 ) );\n        bufferGeometry.computeVertexNormals();\n        // geometry.computeBoundingBox();\n        bufferGeometry.addAttribute('color', new THREE.Float32BufferAttribute( colors, 3 ) );\n        bufferGeometry.addAttribute('behavior', new THREE.Float32BufferAttribute(vertexBehavior,  1));\n        this.geometry = bufferGeometry;\n\n        data.getElevation = (x,z) => {\n            const i = x / SQRT3HALF / UNIT_SIZE;\n            const j = (z + (x/SQRT3HALF/2)) / UNIT_SIZE;\n            const nearVertices = [];\n            let index;\n            if (vertexLookup[Math.floor(i)] && (index = vertexLookup[Math.floor(i)][Math.floor(j)])) {\n                nearVertices.push(vertices[index]);\n            }\n            if (vertexLookup[Math.floor(i)] && (index = vertexLookup[Math.floor(i)][Math.ceil(j)])) {\n                nearVertices.push(vertices[index]);\n            }\n            if (vertexLookup[Math.ceil(i)] && (index = vertexLookup[Math.ceil(i)][Math.floor(j)])) {\n                nearVertices.push(vertices[index]);\n            }\n            if (vertexLookup[Math.ceil(i)] && (index = vertexLookup[Math.ceil(i)][Math.ceil(j)])) {\n                nearVertices.push(vertices[index]);\n            }\n\n            let elevSum = 0;\n            let scoreSum = 0;\n            nearVertices.forEach( vert => {\n                let score = 1 - (Math.sqrt(Math.pow(x-vert.x, 2) + Math.pow(z-vert.z, 2)) / UNIT_SIZE);\n                if (score < 0) {score = 0}\n                elevSum += vert.y * score;\n                scoreSum += score;\n            });\n            // if (nearVertices.length < 4) {\n            //     console.log(\"scoreSum:\", scoreSum.toFixed(2), \"   \", nearVertices.map(v => v.x.toFixed(2) + \",\" + v.z.toFixed(2) + \" \" + v.y.toFixed(2)));\n            // }\n            if (scoreSum > 0) {   // at least one vertex was near\n                return elevSum / scoreSum;\n            } else {   // outside all usable vertices, the elevation is 0\n                return 0;\n            }\n        }\n    }\n});\n","// vertex-color+noise.js - an A-Frame material which interpolates the vertex colors and then adds noise\n// Copyright © 2019 P. Douglas Reeder under the MIT License\n\nimport vertexShader from './vertex-color+noise-vert.glsl'\nimport fragmentShader from './vertex-color+noise-frag.glsl'\n\nAFRAME.registerShader('vertex-color+noise', {\n    schema: {\n        sunPosition: {type: 'vec3', default: {x:-1.0, y:1.0, z:-1.0}},\n        timeMsec: {type: 'time', is: 'uniform'}\n    },\n\n    /**\n     * `init` used to initialize material. Called once.\n     */\n    init: function (data) {\n        // console.log(\"material-vertex-color+noise data:\", data);\n        let sunPos = new THREE.Vector3(data.sunPosition.x, data.sunPosition.y, data.sunPosition.z);\n        this.material = new THREE.ShaderMaterial({\n            uniforms: {\n                sunNormal: {value: sunPos.normalize()},\n                wavesOffset: {type: 'vec3', value: {x:0, y:0, z:0}},\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader\n        });\n    },\n\n    /**\n     * `update` used to update the material. Called on initialization and when data updates.\n     */\n    update: function (data) {\n        if (data.sunPosition) {\n            let sunPos = new THREE.Vector3(data.sunPosition.x, data.sunPosition.y, data.sunPosition.z);\n            this.material.uniforms.sunNormal.value = sunPos.normalize();\n        }\n        if (data.timeMsec) {\n            let time = data.timeMsec / 1000;\n            this.material.uniforms.wavesOffset.value = new THREE.Vector3(Math.sin(time), 0.0, Math.cos(time*1.33333));\n        }\n    },\n});\n","// aframe-atoll-terrain - An A-Frame WebVR primitive with high-resolution terrain surrounded by a low-res sea or plain\n// Copyright © 2019 P. Douglas Reeder under the MIT License\n// Uses equilateral triangles in the high-res area & colors vertexes with sea color at elevation 0\n\nimport GeometryAtollTerrain from './geometry-atoll-terrain';\n\nimport MaterialVertexColorPlusNoise from './vertex-color+noise'\n\nAFRAME.registerPrimitive('a-atoll-terrain', {\n    defaultComponents: {\n        geometry: {\n            primitive: 'atoll-terrain',\n            middleRadius: 100,\n            unitSize: 1,\n            log: false\n        },\n        material: {\n            shader: 'vertex-color+noise',\n            vertexColors: 'vertex'\n        }\n    },\n\n    mappings: {\n        'mean-elevation': 'geometry.meanElevation',\n        'plateau-radius': 'geometry.plateauRadius',\n        'plateau-elevation-min': 'geometry.plateauElevationMin',\n        'plateau-yin-color': 'geometry.plateauYinColor',\n        'plateau-yang-color': 'geometry.plateauYangColor',\n        'middle-radius': 'geometry.middleRadius',\n        'unit-size': 'geometry.unitSize',\n        'far': 'geometry.far',\n        'log': 'geometry.log',\n        'shader': 'material.shader',\n        'land-yin-color': 'geometry.landYinColor',\n        'land-yang-color': 'geometry.landYangColor',\n        'sea-yin-color': 'geometry.seaYinColor',\n        'sea-yang-color': 'geometry.seaYangColor',\n        'sun-position': 'material.sunPosition',\n        'src': 'material.src',\n        'flat-shading': 'material.flatShading'\n    }\n});\n"],"sourceRoot":""}