{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/ImprovedNoise.js","webpack:///./src/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","fade","lerp","a","b","grad","hash","x","y","z","h","u","v","noise","floorX","floorY","floorZ","X","Y","Z","xMinus1","yMinus1","zMinus1","w","A","AA","AB","B","BA","BB","__webpack_exports__","_ImprovedNoise__WEBPACK_IMPORTED_MODULE_0__","_ImprovedNoise__WEBPACK_IMPORTED_MODULE_0___default","AFRAME","registerGeometry","schema","middleRadius","type","default","min","unitSize","max","far","color","seaColor","log","init","data","perlin","SEED","Math","random","SQRT3HALF","sqrt","SIZE","round","UNIT_SIZE","INNER_RADIUS","OUTER_RADIUS","FAR","PLATEAU_EDGE","SCAN_SIZE","ceil","COLOR","THREE","Color","SEA_COLOR","console","geometry","Geometry","vertexLookup","vertexInd","j","quality","vertices","push","Vector3","pitColor","vertexColor","vertex","neighbors","land","sea","vertexAInd","vertexBInd","vertexCInd","vertexDInd","face","Face3","vertexColors","faces","computeBoundingBox","mergeVertices","computeFaceNormals","computeVertexNormals","this","registerPrimitive","defaultComponents","primitive","material","mappings","middle-radius","unit-size","shader","sea-color","metalness","roughness","src","flat-shading"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","// http://mrl.nyu.edu/~perlin/noise/\n\nvar ImprovedNoise = function () {\n\n\tvar p = [ 151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,\n\t\t 23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,\n\t\t 174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,\n\t\t 133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,\n\t\t 89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,\n\t\t 202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,\n\t\t 248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,\n\t\t 178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,\n\t\t 14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,\n\t\t 93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180 ];\n\n\tfor (var i = 0; i < 256 ; i ++) {\n\n\t\tp[256 + i] = p[i];\n\n\t}\n\n\tfunction fade(t) {\n\n\t\treturn t * t * t * (t * (t * 6 - 15) + 10);\n\n\t}\n\n\tfunction lerp(t, a, b) {\n\n\t\treturn a + t * (b - a);\n\n\t}\n\n\tfunction grad(hash, x, y, z) {\n\n\t\tvar h = hash & 15;\n\t\tvar u = h < 8 ? x : y, v = h < 4 ? y : h == 12 || h == 14 ? x : z;\n\t\treturn ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);\n\n\t}\n\n\treturn {\n\n\t\tnoise: function (x, y, z) {\n\n\t\t\tvar floorX = ~~x, floorY = ~~y, floorZ = ~~z;\n\n\t\t\tvar X = floorX & 255, Y = floorY & 255, Z = floorZ & 255;\n\n\t\t\tx -= floorX;\n\t\t\ty -= floorY;\n\t\t\tz -= floorZ;\n\n\t\t\tvar xMinus1 = x - 1, yMinus1 = y - 1, zMinus1 = z - 1;\n\n\t\t\tvar u = fade(x), v = fade(y), w = fade(z);\n\n\t\t\tvar A = p[X] + Y, AA = p[A] + Z, AB = p[A + 1] + Z, B = p[X + 1] + Y, BA = p[B] + Z, BB = p[B + 1] + Z;\n\n\t\t\treturn lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z),\n\t\t\t\t\t\t\tgrad(p[BA], xMinus1, y, z)),\n\t\t\t\t\t\tlerp(u, grad(p[AB], x, yMinus1, z),\n\t\t\t\t\t\t\tgrad(p[BB], xMinus1, yMinus1, z))),\n\t\t\t\t\tlerp(v, lerp(u, grad(p[AA + 1], x, y, zMinus1),\n\t\t\t\t\t\t\tgrad(p[BA + 1], xMinus1, y, z - 1)),\n\t\t\t\t\t\tlerp(u, grad(p[AB + 1], x, yMinus1, zMinus1),\n\t\t\t\t\t\t\tgrad(p[BB + 1], xMinus1, yMinus1, zMinus1))));\n\n\t\t}\n\t}\n};\n\nmodule.exports = ImprovedNoise;\n","// aframe-terrain-plain - An A-Frame WebVR primitive with high-resolution terrain surrounded by a low-res plain\n// Copyright © 2019 P. Douglas Reeder under the MIT License\n// Written using Perlin noise & ideas from aframe-mountain-component by Kevin Ngo.\n\nimport ImprovedNoise from './ImprovedNoise';\n\nAFRAME.registerGeometry('terrain-plain', {\n    schema: {\n        middleRadius: {type: 'number', default: 100, min: 10},\n        unitSize: {type: 'number', default: 1, min: 0.1, max: 1000},\n        far: {type: 'number', default: 4000},\n        color: {type: 'color'},\n        seaColor: {type: 'color'},\n        log: {type: 'boolean', default: false}\n    },\n    init: function (data) {\n        const perlin = new ImprovedNoise();\n        const SEED = Math.random() * 100;\n        const SQRT3HALF = Math.sqrt(3) / 2;\n\n        const SIZE = Math.round(data.middleRadius / data.unitSize);\n        const UNIT_SIZE = data.middleRadius / SIZE;\n\n        const INNER_RADIUS = (SIZE-1) * UNIT_SIZE + 0.0001;\n        const OUTER_RADIUS = (SIZE+1) * UNIT_SIZE + 0.0001;\n        const FAR = data.far > OUTER_RADIUS ? data.far : OUTER_RADIUS;\n        const PLATEAU_EDGE = INNER_RADIUS / 4;\n        const SCAN_SIZE = Math.ceil(SIZE * 1.16);   // empirically determined\n\n        const COLOR = new THREE.Color(data.color);\n        const SEA_COLOR = new THREE.Color(data.seaColor);\n\n        if (data.log) {\n            console.log(\"terrain-plain\", \"SIZE=\"+SIZE, \"SCAN_SIZE=\"+SCAN_SIZE, \"UNIT_SIZE=\"+UNIT_SIZE,\n                \"middleRadius=\"+data.middleRadius, \"FAR=\"+FAR);\n        }\n\n        let geometry = new THREE.Geometry();\n\n        // vertex locations\n        let vertexLookup = {};\n        vertexLookup[-SCAN_SIZE-1] = {};\n        let vertexInd = 0;\n        for (let i= -SCAN_SIZE; i<=SCAN_SIZE; ++i) {\n            vertexLookup[i] = {};\n            for (let j= -SCAN_SIZE; j<=SCAN_SIZE; ++j) {\n                let x = i * SQRT3HALF * UNIT_SIZE;\n                let z = (j - i/2) * UNIT_SIZE;\n                let r = Math.sqrt(x*x + z*z);\n                if (r <= OUTER_RADIUS) {\n                    let y;\n                    if (r <= INNER_RADIUS) {\n                        y = 10;\n                        // generates smooth noisy terrain\n                        for (let quality = 25; quality <= 1500; quality *= 5) {\n                            y += perlin.noise((x+data.middleRadius) / quality, (z+data.middleRadius) / quality, SEED) * Math.min(quality / 2, 150);\n                        }\n\n                        y *= Math.min(INNER_RADIUS - r, PLATEAU_EDGE) / PLATEAU_EDGE;\n\n                        if (y > 0) {\n                            let quality = 5;\n                            y += perlin.noise((x + data.middleRadius) / quality, (z + data.middleRadius) / quality, SEED) * quality / 2;\n                        }\n\n                        // flattens the bottom, so it's continuous with the plain\n                        if (y < 0) {\n                            y = 0;\n                        }\n                    } else if (r <= data.middleRadius) {\n                        y = 0;\n                    } else {\n                        x *= FAR / r;\n                        z *= FAR / r;\n                        y = 0;\n                    }\n\n                    vertexLookup[i][j] = vertexInd++;\n                    geometry.vertices.push(new THREE.Vector3(x, y, z));\n                }\n            }\n        }\n        vertexLookup[SCAN_SIZE+1] = {};\n\n        // vertex colors\n        let pitColor = new THREE.Color(0x404040);   // dark gray\n        pitColor.lerp(COLOR, 0.75);\n\n        let vertexColor = {};\n        for (let i= -SCAN_SIZE; i<=SCAN_SIZE; ++i) {\n            vertexColor[i] = {};\n            for (let j = -SCAN_SIZE; j <= SCAN_SIZE; ++j) {\n                let vertex = geometry.vertices[vertexLookup[i][j]];\n                if (vertex) {\n                    if (vertex.y > 0) {\n                        vertexColor[i][j] = COLOR;\n                    } else {\n                        let r = Math.sqrt(vertex.x*vertex.x + vertex.z*vertex.z);\n                        if (r > INNER_RADIUS) {\n                            vertexColor[i][j] = SEA_COLOR;\n                        } else {\n                            let neighbors = [];\n                            neighbors[0] = geometry.vertices[vertexLookup[i][j - 1]];\n                            neighbors[1] = geometry.vertices[vertexLookup[i - 1][j - 1]];\n                            neighbors[2] = geometry.vertices[vertexLookup[i - 1][j]];\n                            neighbors[3] = geometry.vertices[vertexLookup[i][j + 1]];\n                            neighbors[4] = geometry.vertices[vertexLookup[i + 1][j + 1]];\n                            neighbors[5] = geometry.vertices[vertexLookup[i + 1][j]];\n                            let land = 0, sea = 0;\n                            for (let n = 0; n < 6; ++n) {\n                                if (neighbors[n]) {\n                                    if (neighbors[n].y > 0) {\n                                        ++land;\n                                    } else {\n                                        ++sea;\n                                    }\n                                }\n                            }\n                            if (land === 0) {   // open sea\n                                vertexColor[i][j] = SEA_COLOR;\n                            } else if (sea === 0) {   // pit completely surrounded by land\n                                vertexColor[i][j] = pitColor;\n                            } else {\n                                let color = new THREE.Color(0x71615b);   // brownish-gray beach\n                                color.lerp(COLOR, land / (land+sea));\n                                vertexColor[i][j] = color;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // faces\n        for (let i= -SCAN_SIZE; i<=SCAN_SIZE; ++i) {\n            for (let j = -SCAN_SIZE; j <= SCAN_SIZE; ++j) {\n                let vertexAInd = vertexLookup[i][j];\n                if (geometry.vertices[vertexAInd]) {\n                    let vertexBInd = vertexLookup[i][j-1];\n\n                    let vertexCInd = vertexLookup[i-1][j-1];\n\n                    let vertexDInd = vertexLookup[i-1][j];\n\n                    if (typeof vertexBInd !== 'undefined' && typeof vertexCInd !== 'undefined') {\n                        let face = new THREE.Face3(vertexAInd, vertexBInd, vertexCInd);\n                        face.vertexColors[0] = vertexColor[i  ][j  ];\n                        face.vertexColors[1] = vertexColor[i  ][j-1];\n                        face.vertexColors[2] = vertexColor[i-1][j-1];\n\n                        geometry.faces.push(face);\n                    }\n                    if (typeof vertexCInd !== 'undefined' && typeof vertexDInd !== 'undefined') {\n                        let face = new THREE.Face3(vertexAInd, vertexCInd, vertexDInd);\n                        face.vertexColors[0] = vertexColor[i  ][j  ];\n                        face.vertexColors[1] = vertexColor[i-1][j-1];\n                        face.vertexColors[2] = vertexColor[i-1][j  ];\n\n                        geometry.faces.push(face);\n                    }\n                }\n            }\n        }\n\n        geometry.computeBoundingBox();\n        geometry.mergeVertices();\n        geometry.computeFaceNormals();\n        geometry.computeVertexNormals();\n        this.geometry = geometry;\n    }\n});\n\n\nAFRAME.registerPrimitive('a-terrain-plain', {\n    defaultComponents: {\n        geometry: {\n            primitive: 'terrain-plain',\n            middleRadius: 100,\n            unitSize: 1,\n            log: false\n        },\n        material: {\n            vertexColors: 'vertex'\n        }\n    },\n\n    mappings: {\n        'middle-radius': 'geometry.middleRadius',\n        'unit-size': 'geometry.unitSize',\n        'far': 'geometry.far',\n        'log': 'geometry.log',\n        'shader': 'material.shader',\n        'color': 'geometry.color',\n        'sea-color': 'geometry.seaColor',\n        'metalness': 'material.metalness',\n        'roughness': 'material.roughness',\n        'src': 'material.src',\n        'flat-shading': 'material.flatShading'\n    }\n});\n"],"sourceRoot":""}